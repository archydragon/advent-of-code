-module(d15).
-export([run/0]).

run() ->
    % {Sensor, Beacon}
    Input = [
        {{3428425, 2345067}, {3431988, 2379841}},
        {{928237, 25774}, {1212315, -161555}},
        {{2061220, 2396791}, {2038311, 2495160}},
        {{1830400, 2994568}, {1910058, 3117415}},
        {{2485733, 2625804}, {2038311, 2495160}},
        {{1855873, 3971916}, {1910058, 3117415}},
        {{119582, 3929652}, {311197, 4221202}},
        {{1069031, 3509672}, {1910058, 3117415}},
        {{3368023, 2213635}, {3431988, 2379841}},
        {{3713877, 2460862}, {3431988, 2379841}},
        {{3593503, 2174008}, {3507689, 2000000}},
        {{501760, 93436}, {1212315, -161555}},
        {{3712703, 214999}, {3507689, 2000000}},
        {{1594824, 2790273}, {1910058, 3117415}},
        {{2539549, 3190814}, {1910058, 3117415}},
        {{3522790, 2671548}, {3431988, 2379841}},
        {{1001452, 1327490}, {1212315, -161555}},
        {{629209, 2451628}, {-416149, 2226089}},
        {{2636827, 1146266}, {3507689, 2000000}},
        {{3909, 625124}, {1212315, -161555}},
        {{3950231, 3688780}, {3888160, 3226725}},
        {{3449978, 2328058}, {3431988, 2379841}},
        {{3974214, 2582925}, {3888160, 3226725}},
        {{82663, 3225533}, {311197, 4221202}},
        {{1958305, 2292045}, {2038311, 2495160}},
        {{3465738, 2123353}, {3507689, 2000000}},
        {{2940758, 3884337}, {2746166, 4800483}},
        {{3429173, 2275591}, {3431988, 2379841}},
        {{1527349, 38565}, {1212315, -161555}},
        {{3049925, 2498038}, {3431988, 2379841}},
        {{1593202, 3335178}, {1910058, 3117415}},
        {{3175520, 3230234}, {3888160, 3226725}}
    ],
    NeedY = 2000000,

    % part 1
    BeaconsXInY = lists:uniq([BX || {_, {BX, BY}} <- Input, BY == NeedY]),

    Coverage = coverage_y(Input, [], NeedY),
    Points = lists:uniq(lists:flatten([lists:seq(A, B) || {A, B} <- Coverage])),

    io:fwrite("~w~n", [length(Points) - length(BeaconsXInY)]),

    % part 2
    Pairs = [{{S1, distance(S1, B1)}, {S2, distance(S2, B2)}} || {S1, B1} <- Input, {S2, B2} <- Input, S1 /= S2],
    Aligned = lists:uniq(find_aligned(Pairs, [])),
    Lines = [ border(A) || A <- Aligned ],
    [{X1, X2, Y1, Y2}, {X3, X4, Y3, Y4} | _] = Lines,
    IX = trunc(-((X1*Y2-X2*Y1)*(X4-X3)-(X3*Y4-X4*Y3)*(X2-X1))/((Y1-Y2)*(X4-X3)-(Y3-Y4)*(X2-X1))),
    IY = trunc(((Y3-Y4)*(-IX)-(X3*Y4-X4*Y3))/(X4-X3)),
    io:fwrite("~p~n", [4000000 * IX + IY]).

distance({SX, SY}, {BX, BY}) -> abs(BX - SX) + abs(BY - SY).

% for part 1
coverage_y([], Acc, _Yyy) ->
    Acc;
coverage_y([{{SX, SY} = Sensor, Beacon} | Tail], Acc, Yyy) ->
    Range = distance(Sensor, Beacon),
    D = Range - abs(SY - Yyy),
    case D >= 0 of
        true  -> coverage_y(Tail, [{SX - D, SX + D}| Acc], Yyy);
        false -> coverage_y(Tail, Acc, Yyy)
    end.

% for part 2
find_aligned([], Acc) ->
    Acc;
find_aligned([{{S1, D1} = P1, {S2, D2} = P2} | Tail], Acc) ->
    case distance(S1, S2) - D1 - D2 of
        2 -> find_aligned(Tail, [lists:sort([P1, P2]) | Acc]);
        _ -> find_aligned(Tail, Acc)
    end.

border([{{X1, Y1}, D1}, {{X2, Y2}, _D2}]) when X1 =< X2, Y1 =< Y2 ->
    {
        X1 + D1 + 1, X1,
        Y1, Y1 + D1 + 1
    };
border([{{X1, Y1}, D1}, {{X2, Y2}, _D2}]) when X1 =< X2, Y1 > Y2 ->
    {
        X1 + D1 + 1, X1,
        Y1, Y1 - D1 - 1
    }.
